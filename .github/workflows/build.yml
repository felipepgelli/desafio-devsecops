name: build

on:
  push:
    branches: [ "main", "develop" ]
  workflow_dispatch:

jobs:
  ci:
    name: CI + Security + Deploy (Minikube DES/PRD)
    runs-on: [self-hosted, Windows, X64]
    defaults:
      run:
        shell: cmd

    env:
      MODULE_DIR: app\quarkus-quickstarts\getting-started
      IMAGE_TAG: getting-started:temurin
      JACOCO_XML: target/site/jacoco/jacoco.xml

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      # =========================
      # BUILD + TEST + COVERAGE
      # =========================
      - name: Build & Test (gera cobertura JaCoCo)
        shell: cmd
        working-directory: ${{ env.MODULE_DIR }}
        run: .\mvnw.cmd -B clean verify -D"quarkus.package.jar.type=fast-jar"

      - name: SonarQube (com cobertura)
        shell: cmd
        working-directory: ${{ env.MODULE_DIR }}
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: >
          .\mvnw.cmd -B sonar:sonar
          -Dsonar.host.url=${{ env.SONAR_HOST_URL }}
          -Dsonar.login=${{ env.SONAR_TOKEN }}
          -Dsonar.projectKey=quarkus-getting-started
          -Dsonar.projectName=quarkus-getting-started
          -Dsonar.coverage.jacoco.xmlReportPaths=${{ env.JACOCO_XML }}

      # =========================
      # DOCKER IMAGE (TEMURIN)
      # =========================
      - name: Docker build (Temurin 17)
        shell: pwsh
        working-directory: ${{ env.MODULE_DIR }}
        run: docker build -f src\main\docker\Dockerfile.jvm -t ${{ env.IMAGE_TAG }} .

      # =========================
      # TRIVY SCANS (IMAGE + FS)
      # =========================
      - name: Trivy image → SARIF + TXT
        shell: pwsh
        continue-on-error: true  # não falhar o job por vulnerabilidades encontradas
        run: |
          trivy image --scanners vuln,misconfig,secret --format sarif -o trivy-image.sarif $env:IMAGE_TAG
          if (!(Test-Path docs\scans)) { New-Item -ItemType Directory -Path docs\scans | Out-Null }
          trivy image --scanners vuln,misconfig,secret --severity CRITICAL $env:IMAGE_TAG > docs\scans\trivy-image-${{ env.IMAGE_TAG }}.txt

      - name: Upload SARIF (Trivy Image)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image.sarif
          category: trivy-image

      - name: Trivy filesystem → SARIF + TXT
        shell: pwsh
        working-directory: ${{ env.MODULE_DIR }}
        continue-on-error: true
        run: |
          trivy fs --scanners vuln,misconfig,secret --format sarif -o trivy-fs.sarif .
          Copy-Item trivy-fs.sarif ..\..\..\trivy-fs.sarif
          cd ..\..\..
          if (!(Test-Path docs\scans)) { New-Item -ItemType Directory -Path docs\scans | Out-Null }
          trivy fs --scanners vuln,misconfig,secret --severity CRITICAL $env:MODULE_DIR > docs\scans\trivy-fs-getting-started.txt

      - name: Upload SARIF (Trivy FS)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-fs.sarif
          category: trivy-fs

      - name: Commit evidências Trivy (TXT)
        if: always()
        shell: pwsh
        run: |
          git config user.email "ci@local"
          git config user.name "ci-bot"
          git add docs\scans\*.txt
          git commit -m "docs(scans): atualiza evidências Trivy (image+fs)" || echo "nada para commitar"

      # =========================
      # SELEÇÃO DE AMBIENTE (DES/PRD)
      # =========================
      - name: Definir namespace e pasta K8s por branch
        shell: pwsh
        run: |
          if ("${{ github.ref }}" -eq "refs/heads/main") {
            echo "TARGET_NS=prd" >> $env:GITHUB_ENV
            echo "K8S_DIR=k8s\prd" >> $env:GITHUB_ENV
          } else {
            echo "TARGET_NS=des" >> $env:GITHUB_ENV
            echo "K8S_DIR=k8s\des" >> $env:GITHUB_ENV
          }
          Write-Host "Target NS: $env:TARGET_NS"
          Write-Host "K8s Dir:  $env:K8S_DIR"

      # =========================
      # DEPLOY (MINIKUBE - DES/PRD)
      # =========================
      - name: Kubectl context
        shell: pwsh
        run: |
          kubectl config use-context minikube
          kubectl cluster-info

      - name: Garantir namespace
        shell: pwsh
        run: kubectl create namespace $env:TARGET_NS --dry-run=client -o yaml | kubectl apply -f -

      - name: Carregar imagem local no Minikube
        shell: pwsh
        run: minikube image load $env:IMAGE_TAG

      - name: Aplicar manifests (por branch)
        shell: pwsh
        run: kubectl apply -n $env:TARGET_NS -f $env:K8S_DIR

      - name: Validar rollout
        shell: pwsh
        run: kubectl rollout status -n $env:TARGET_NS deploy/getting-started --timeout=120s

      - name: Mostrar objetos (evidência)
        shell: pwsh
        run: kubectl get deploy,po,svc -n $env:TARGET_NS -l app=getting-started -o wide
